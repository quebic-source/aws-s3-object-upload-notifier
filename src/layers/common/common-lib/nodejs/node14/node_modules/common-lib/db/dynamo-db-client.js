const AWS = require("aws-sdk");
const {
    CREATED_AT_FIELD,
    MODIFIED_AT_FIELD,
    PK_FIELD,
    SK_FIELD,
    PRIMARY_GSI
} = require("../consts/dynamo-db-const");
const { preparePaginationDBRequest, preparePaginatedResponse, PageRequest } = require("common-lib/utils/pagination-utils");

const pkAttributeKey = `#${PK_FIELD}`;
const pkValueKey = `:${PK_FIELD}`;

const skAttributeKey = `#${SK_FIELD}`;
const skValueKey = `:${SK_FIELD}`;

const defaultPageSize = 100;

class DynamoDBClient {
    constructor({ table }) {
        this._table = table;
        this._dynamoDB = new AWS.DynamoDB();
        this._docClient = new AWS.DynamoDB.DocumentClient();
    }

    async findAll() {
        const params = {
            TableName: this._table
        };
        const resp = await this._docClient.scan(params).promise();
        return resp.Items;
    }

    async findAllByPK(pk, pageRequest=new PageRequest({})) {
        const dbPageRequest = preparePaginationDBRequest(pk, pageRequest);

        const ExpressionAttributeNames = {};
        ExpressionAttributeNames[pkAttributeKey] = PK_FIELD;

        const ExpressionAttributeValues = {};
        ExpressionAttributeValues[pkValueKey] = pk;

        const params = {
            TableName: this._table,
            KeyConditionExpression: `${pkAttributeKey} = ${pkValueKey}`,
            ExpressionAttributeNames,
            ExpressionAttributeValues
        };
        return await this.queryWithPaginate(params, dbPageRequest);
    }

    async findByPKAndSK(pk, sk) {
        const ExpressionAttributeNames = {};
        ExpressionAttributeNames[pkAttributeKey] = PK_FIELD;
        ExpressionAttributeNames[skAttributeKey] = SK_FIELD;

        const ExpressionAttributeValues = {};
        ExpressionAttributeValues[pkValueKey] = pk;
        ExpressionAttributeValues[skValueKey] = sk;

        const params = {
            TableName: this._table,
            KeyConditionExpression: `${pkAttributeKey} = ${pkValueKey} and ${skAttributeKey} = ${skValueKey}`,
            ExpressionAttributeNames,
            ExpressionAttributeValues
        };
        return await this.query(params);
    }

    async findByPKAndBeginsWithSK(pk, skPrefix, pageRequest=new PageRequest({})) {
        const dbPageRequest = preparePaginationDBRequest(pk, pageRequest);

        const ExpressionAttributeNames = {};
        ExpressionAttributeNames[pkAttributeKey] = PK_FIELD;
        ExpressionAttributeNames[skAttributeKey] = SK_FIELD;

        const ExpressionAttributeValues = {};
        ExpressionAttributeValues[pkValueKey] = pk;
        ExpressionAttributeValues[skValueKey] = skPrefix;

        const params = {
            TableName: this._table,
            ScanIndexForward: pageRequest.orderAsc,
            KeyConditionExpression: `${pkAttributeKey} = ${pkValueKey} and begins_with(${skAttributeKey}, ${skValueKey})`,
            ExpressionAttributeNames,
            ExpressionAttributeValues
        };
        return await this.queryWithPaginate(params, dbPageRequest);
    }

    async findByPKAndSKCustomIndex(pkField, pk, skField, sk, indexName) {
        const ExpressionAttributeNames = {};
        ExpressionAttributeNames[pkAttributeKey] = pkField;
        ExpressionAttributeNames[skAttributeKey] = skField;

        const ExpressionAttributeValues = {};
        ExpressionAttributeValues[pkValueKey] = pk;
        ExpressionAttributeValues[skValueKey] = sk;

        const params = {
            TableName: this._table,
            IndexName: indexName,
            KeyConditionExpression: `${pkAttributeKey} = ${pkValueKey} and ${skAttributeKey} = ${skValueKey}`,
            ExpressionAttributeNames,
            ExpressionAttributeValues
        };
        return await this.query(params);
    }

    // custom query
    async query(params) {
        const resp = await this.queryWithPaginate(params);
        return resp.Items;
    }

    async queryWithPaginate(params, dbPageRequest=null) {
        let _postprocessor = resp=>resp;

        if (dbPageRequest !== null) {
            const { pageRequest } = dbPageRequest;
            const { pageSize } = pageRequest;
            params.Limit = pageSize;

            const { exclusiveStartKey } = dbPageRequest;
            if (exclusiveStartKey !== null) {
                params.ExclusiveStartKey = exclusiveStartKey;
            }

            _postprocessor = resp=>preparePaginatedResponse(resp, pageRequest);
        } else {
            params.Limit = defaultPageSize;
        }

        const resp = await this._docClient.query(params).promise();
        return _postprocessor(resp);
    }

    async findByIDs(ids, projection=[]) {
        const Keys = [];
        for (let idDic of ids) {
            const key = {};
            key[PK_FIELD] = {'S': idDic[PK_FIELD]};
            key[SK_FIELD] = {'S': idDic[SK_FIELD]};
            Keys.push(key)
        }
        const ProjectionExpression = projection.join(',');
        const RequestItems = {};
        RequestItems[this._table] = {Keys, ProjectionExpression}
        var params = {
            RequestItems
        };
        const resp = await this._dynamoDB.batchGetItem(params).promise();
        console.log("resp", resp);
        return resp.Responses[this._table];
    }

    async save(pk, sk, request) {
        request[PK_FIELD] = pk;
        request[SK_FIELD] = sk;

        const today = new Date().toISOString();

        if (!request[CREATED_AT_FIELD]) {
            request[CREATED_AT_FIELD] = today;
        }

        if (!request[MODIFIED_AT_FIELD]) {
            request[MODIFIED_AT_FIELD] = today;
        }

        return await this._docClient.put({TableName: this._table, Item: request}).promise();
    }

    async deleteByPKAndSK(pk, sk) {
        const Key = {};
        Key[PK_FIELD] = pk;
        Key[SK_FIELD] = sk;
        const params = {
            TableName: this._table,
            Key
        };
        return await this._docClient.delete(params).promise();
    }
}

module.exports = DynamoDBClient;